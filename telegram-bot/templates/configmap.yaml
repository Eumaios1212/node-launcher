apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "telegram-bot.fullname" . }}
data:
  constants.py: |
    import os
    import logging
    import random

    # Enable logging
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        level=logging.INFO)
    logger = logging.getLogger(__name__)

    DEBUG = bool(os.environ['DEBUG'] == 'True') if 'DEBUG' in os.environ else False
    TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN', '')

    NETWORK_TYPES = ["TESTNET", "CHAOSNET"]
    NETWORK_TYPE = os.getenv("NETWORK_TYPE").upper() \
        if os.getenv("NETWORK_TYPE", "notFound").upper() in NETWORK_TYPES and not DEBUG else 'TESTNET'

    # Set BINANCE_NODE_IP depending on mode (if None, no Binance jobs are not executed)
    if DEBUG:
        BINANCE_NODE_IPS = ['localhost', '0.0.0.0']
        BINANCE_DEX_ENDPOINT = "https://testnet-dex-atlantic.binance.org"
    else:
        BINANCE_NODE_IPS = [binance_ip for binance_ip in
                            os.environ['BINANCE_NODE_IPS'].split(",")] \
            if 'BINANCE_NODE_IPS' in os.environ and os.environ['BINANCE_NODE_IPS'] != "" \
            else []
        BINANCE_DEX_ENDPOINT = "https://dex.binance.org" if NETWORK_TYPE == 'CHAOSNET' \
                else "https://testnet-dex-atlantic.binance.org"

    ETHEREUM_NODE_IPS = list(filter(None, os.environ.get('ETHEREUM_NODE_IPS', '').split(",")))
    BITCOIN_NODE_IPS = list(filter(None, os.environ.get('BITCOIN_NODE_IPS', '').split(",")))
    BITCOIN_NODE_USERNAMES = list(filter(None, os.environ.get('BITCOIN_NODE_USERNAMES', '').split(",")))
    BITCOIN_NODE_PASSWORDS = list(filter(None, os.environ.get('BITCOIN_NODE_PASSWORDS', '').split(",")))

    if (len(BITCOIN_NODE_IPS) != len(BITCOIN_NODE_USERNAMES)) or (len(BITCOIN_NODE_IPS) != len(BITCOIN_NODE_PASSWORDS)):
        logger.warning("Error while reading your bitcoin nodes ip addresses!\n"
                       "You must set exactly the same number of IPs, usernames and passwords to the json-rpc api.\n"
                       "You set:\n"
                       f"BITCOIN_NODE_IPS array length: ({len(BITCOIN_NODE_IPS)})\n"
                       f"BITCOIN_NODE_USERNAMES array length: ({len(BITCOIN_NODE_USERNAMES)})\n"
                       f"BITCOIN_NODE_PASSWORDS array length: ({len(BITCOIN_NODE_PASSWORDS)})\n")
        BITCOIN_NODE_IPS.clear()

    ALLOWED_USER_IDS = 'ALL' if os.getenv("ALLOWED_USER_IDS", "notFound").upper() == 'ALL' \
        else [int(admin_id) for admin_id in os.getenv("ALLOWED_USER_IDS", []).split(",")]

    # By how much we multiply the notification timeout in case of continuous Thornode attribute changes
    NOTIFICATION_TIMEOUT_MULTIPLIER = 1.5
    # Base notification timeout in seconds
    INITIAL_NOTIFICATION_TIMEOUT = 15

    # Emojis for status of THORNodes
    STATUS_EMOJIS = {
        "unknown": "❓",
        "whitelisted": "📋",
        "standby": "📆",
        "ready": "🙋🏽‍♂️",
        "active": "💚",
        "disabled": "🔴"
    }

    MONITORED_STATUSES = ["standby", "ready", "active"]

    JOB_INTERVAL_IN_SECONDS = 5 if DEBUG else 30

    # Paths
    storage_path = os.sep.join(
        [os.path.dirname(os.path.realpath(__file__)), os.path.pardir, 'storage'])
    session_data_path = os.sep.join([storage_path, 'session.data'])

    CONNECTION_TIMEOUT = 10

    REQUEST_POSTFIX = '?height=0'  # currently needed to get correct results due to a bug in thornodes

  thorchain_network_service.py: |
    import random
    import aiohttp
    import requests

    from requests.adapters import HTTPAdapter
    from requests.packages.urllib3.util.retry import Retry

    from constants import *


    def get_node_accounts():
        path = ":8080/nodeaccounts.json" if DEBUG else ":1317/thorchain/nodeaccounts"
        return get_request_json_thorchain(url_path=path)


    def get_node_status(node_ip=None):
        status_path = {
            "TESTNET": ":26657/status",
            "CHAOSNET": ":27147/status"
        }[NETWORK_TYPE]

        return get_request_json_thorchain(url_path=status_path, node_ip=node_ip)


    def get_latest_block_height(node_ip=None) -> str:
        return str(get_node_status(node_ip)['result']['sync_info']['latest_block_height'])


    def is_thorchain_catching_up(node_ip=None) -> bool:
        return get_node_status(node_ip)['result']['sync_info']['catching_up']


    def is_midgard_api_healthy(node_ip) -> bool:
        try:
            get_request_json_thorchain(url_path=":8080/v1/health", node_ip=node_ip)
        except Exception as e:
            logger.exception(e)
            return False

        return True


    def get_number_of_unconfirmed_transactions(node_ip) -> int:
        unconfirmed_txs_path = {
            "TESTNET": ":26657/num_unconfirmed_txs",
            "CHAOSNET": ":27147/num_unconfirmed_txs"
        }[NETWORK_TYPE]
        return int(get_request_json_thorchain(url_path=unconfirmed_txs_path, node_ip=node_ip)['result']['total'])


    def get_network_data(node_ip=None):
        return get_request_json_thorchain(url_path=f":8080/v1/network", node_ip=node_ip)


    def is_binance_node_healthy(binance_node_ip) -> bool:
        health_path = {
            "TESTNET": ":26657/health",
            "CHAOSNET": ":27147/health"
        }[NETWORK_TYPE]

        try:
            get_request_json(url=f"http://{binance_node_ip}{health_path}")
        except Exception as e:
            logger.exception(e)
            return False

        return True


    def get_thorchain_blocks_per_year(node_ip=None):
        constants = get_request_json_thorchain(url_path=f":8080/v1/thorchain/constants", node_ip=node_ip)
        return constants['int_64_values']['BlocksPerYear']


    def get_asgard_json() -> dict:
        path = ':8080/asgard.json' if DEBUG else f":1317/thorchain/vaults/asgard"
        return get_request_json_thorchain(url_path=path)


    def get_yggdrasil_json() -> dict:
        path = ":8080/yggdrasil.json" if DEBUG else ":1317/thorchain/vaults/yggdrasil"
        return get_request_json_thorchain(url_path=path)


    def get_binance_balance(address: str) -> dict:
        return get_request_json(url=f"{BINANCE_DEX_ENDPOINT}/api/v1/account/{address}")['balances']


    async def get_pool_addresses(node_ip: str):
        async with aiohttp.ClientSession() as session:
            async with session.get(
                    f'http://{node_ip}:8080/v1/thorchain/pool_addresses',
                    timeout=CONNECTION_TIMEOUT) as response:
                if response.status != 200:
                    raise Exception(
                        f"Error while getting pool address. " +
                        "Endpoint responded with: {await resp.text()} \n"
                        "Code: ${str(resp.status)}")

                return await response.json()


    def get_request_json(url: str) -> dict:
        response = requests_retry_session().get(url=url, timeout=CONNECTION_TIMEOUT)

        if response.status_code != 200:
            raise BadStatusException(response)

        return response.json()

    def requests_retry_session(
        retries=6,
        backoff_factor=1,
        status_forcelist=(500, 502, 504),
        session=None,
    ):
        """
        Creates a request session that has auto retry
        """
        session = session or requests.Session()
        retry = Retry(
            total=retries,
            read=retries,
            connect=retries,
            backoff_factor=backoff_factor,
            status_forcelist=status_forcelist,
        )
        adapter = HTTPAdapter(max_retries=retry)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        return session

    def get_request_json_thorchain(url_path: str, node_ip: str=None) -> dict:
        if DEBUG:
            node_ip = 'localhost'

        if node_ip:
            return get_request_json(url=f"http://{node_ip}{url_path}{REQUEST_POSTFIX}")

        seeding_node_url = \
            {"TESTNET": "https://testnet-seed.thorchain.info", "CHAOSNET": "https://chaosnet-seed.thorchain.info"}[
                NETWORK_TYPE]

        available_node_ips = requests.get(url=seeding_node_url, timeout=CONNECTION_TIMEOUT).json()

        random.shuffle(available_node_ips)
        for random_node_ip in available_node_ips:
            try:
                return get_request_json(url=f"http://{random_node_ip}{url_path}{REQUEST_POSTFIX}")
            except Exception:
                continue
        raise Exception("No seed node returned a valid response!")


    class BadStatusException(Exception):

        def __init__(self, response: requests.Response):
            self.message = f"Error while network request.\n" \
                           f"Received status code: {str(response.status_code)}\n" \
                           f"Received response: {response.text}"

        def __str__(self):
            return self.message
